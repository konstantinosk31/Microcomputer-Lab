---
#{{{
# vim: set conceallevel=0:
title: 'Χρήση των Timers και του ADC στον AVR'
subtitle: 'Εργαστήριο Μικροϋπολογιστών'
author:
- Κριθαρίδης Κωνσταντίνος, $el21045$
- Μπαλάτος Δημήτριος, $el21170$
date: '29 Οκτωβρίου 2024'
subject: ''
keywords: ''
abstract: ''
lang: el_GR
linkcolor: blue
fontsize: 12pt
#fontfamily: 'GFS Artemisia'
mainfont: 'CMU Serif'
sansfont: 'CMU Sans Serif:style=BoldItalic'
monofont: 'CMU Typewriter Text:style=LightOblique'
documentclass: article
classoption: ''
toc: false
papersize: a4
geometry:
- margin=1.5cm
urlcolor: blue
toccolor: black
links-as-notes: false
numbersections: true
#}}}
---

# Ζήτημα 3.1

Στην αρχή του προγράμματος αποθηκεύουμε στο cseg σε διαδοχικές θέσεις μνήμης τις 
τιμές που θα παίρνει το duty cycle που θα δίνεται από τη μεταβλητή `DC_VALUE`.  
Θέτουμε το `PORTB` ως έξοδο και το `PORTD` ως είσοδο και αρχικοποιούμε μέσω των 
`TCCR1A`, `TCCR1B` τον μετρητή `TMR1A` σε λειτουργία Fast PWM, $8\;\rm bit$, 
non-inverting output με $N = 256$, έχοντας $\tt BOTTOM = 0$ και $\tt TOP = \it 
0x00ff = 255$. Για να ανιχνεύουμε το πάτημα των `PD3`, `PD4` ενεργοποιούμε τις 
διακοπές `PCINT19` (`PD3`) και `PCINT20` (`PD4`) στον καταχωρητή `PCMSK2`, όπως 
και γενικά τo *Pin Change Interrupt 2* μέσω του `PCICR`. Αρχικοποιούμε το $i$ να 
ισούται με 6 (που αντιστοιχεί στην 6η θέση του πίνακα, δηλαδή στο duty cycle 
$50\%$) και τον καταχωρητή `Z` να δείχνει στην $i$-οστή θέση του πίνακα στη 
μνήμη προγράμματος.  Τέλος, ενεργοποιούμε την καθολική σημαία διακοπών για να 
λειτουργεί ο κώδικας.

Στο κύριο πρόγραμμα θέτουμε το duty cycle να ισούται με τη θέση μνήμης που 
δείχνει ο καταχωρητής Z και περιμένουμε 10ms πριν επαναλάβουμε. Η ρουτίνα 
εξυπηρέτησης διακοπών pc2isr ανιχνεύει αλλαγή κατάστασης των PD3 και PD4. 
Έχοντας έναν βοηθητικό καταχωρητή στον οποίο έχουμε αποθηκευμένη κάθε φορά την 
προηγούμενη κατάσταση του PIND μπορούμε να καταλάβουμε ποιά αλλαγή στα PD3, PD4 
είναι που μόλις συνέβη. Συγκεκριμένα, με το cur_PIND AND (NOT prev_PIND) 
ανιχνεύουμε το bit του PIND που μόλις έγινε 1 ενώ πριν ήταν 0. Αν πατήθηκε PD3 
και δεν έχουμε φτάσει στο τέλος του πίνακα προχωράμε το i και το Z κατά 1 θέση 
μπροστά  στον πίνακα, ενώ αν πατήθηκε το PD4 και δεν έχουμε φτάσει στην αρχή του 
πίνακα, προχωράμε το i και το Z κατά 1 θέση πίσω στον πίνακα.

```asm {source=Ex3_1/Ex3_1/main.asm}
```

# Ζήτημα 3.2
Το μεγαλύτερο μέρος του κώδικα είναι μετατροπή της παραπάνω άσκησης από Assembly 
σε C. Μερικά σημαντικά σημεία:

- Ενεργοποιούμε επιπλέον το `ADC0`, με τα κατάλληλα flags:
    - $\it V_{ref} = 5\;\rm V$
    - Χρήση `ADC0`
    - Enable
    - No interrupt
    - Refresh $125\;\rm kHz$
- Αξιοποιούμε μέρος του `PORTD` για input (pins 3, 4) και το υπόλοιπο για output
- Το timer handler αντιμετωπίζει και την αλλαγή αναμένου led του `PORTD`, 
  ανάλογα τον μέσο όρο μετρήσεων του `ADC0`
    - Υπολογίζουμε τον μέσο όρο μέσο κυκλικής λίστας υλοποιημένης με πίνακα

```asm {source=Ex3_2_vim/main.c}
```

# Ζήτημα 3.3
