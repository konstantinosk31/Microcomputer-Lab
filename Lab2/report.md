---
#{{{
# vim: set conceallevel=0:
title: 'Χρήση εξωτερικών διακοπών στον Μικροελεγκτή AVR'
subtitle: 'Εργαστήριο Μικροϋπολογιστών'
author:
- Κριθαρίδης Κωνσταντίνος, $el21045$
- Μπαλάτος Δημήτριος, $el21170$
date: '22 Οκτωβρίου 2024'
subject: ''
keywords: ''
abstract: ''
lang: el_GR
linkcolor: blue
fontsize: 12pt
fontfamily: 'GFS Artemisia'
#mainfont: 'CMU Serif'
#sansfont: 'CMU Sans Serif:style=BoldItalic'
#monofont: 'CMU Typewriter Text:style=LightOblique'
documentclass: article
classoption: ''
toc: false
papersize: a4
geometry:
- margin=1.5cm
urlcolor: blue
toccolor: black
links-as-notes: false
numbersections: true
#}}}
---

## Ζήτημα 2.1
Τροποποιούμε τον κώδικα του σχήματος 2.1. Προσθέτουμε ρουτίνα εξυπηρέτησης της διακοπής `INT1` που αυξάνει τον μετρητή διακοπών `INT1`, `int1counter`, κάνοντάς τον reset μετά την τιμή 63. Προσθέτουμε έλεγχο ώστε αν είναι πατημένο το `PB5` τη στιγμή που γίνεται η διακοπή, αυτή να μην καταχωρηθεί στον μετρητή διακοπών `INT1`. Επιπλέον προσθέτουμε την ροή ελέγχου `isrloop` ώστε να αποφύγουμε το φαινόμενο του σπινθηρισμού, σύμφωνα με το σχήμα 2.4.

```asm {source=Ex2_1/Ex2_1/main.asm}
```

## Ζήτημα 2.2
Για το Ζήτημα 2.2, τροποποιηθηκε ο δοσμένος κώδικας. Αρχικά αλλάξαμε το όριο μετρητή από 16 σε 32, όπως ζητήθηκε από την εκφώνηση. Για την αντιμετώπιση των interrupts, χρειάστηκε να αλλάξουμε ορισμένα σημεία ώστε να αντιστοιχούν στο `INT1` αντί του `INT0`. Η εξυπηρέτηση του interrupt καθαυτή είναι απλή, αξιοποιούμε βρόχο για να διαβάσουμε τα αναμμένα bits του `PORTB` (κρατάμε τα 5 LSBs με ενα bitwise AND) και τα εκτυπωνουμε.

```asm {source=Ex2_2/Ex2_2/main.asm}
```

## Ζήτημα 2.3
Για το Ζήτημα 2.3 χρησιμοποιούμε μια ρουτίνα `delay_mS` που καθυστερεί για 1ms. Κάθε ms ελέγχουμε σε ποιά κατάσταση βρίσκεται ο αυτοματισμός μας με βάση ένα `FLAG` (0: σβηστά LEDs, 1: `PB0` αναμμένο, 2: όλα τα LEDs του `PORTB` αναμμένα) που αρχικά είναι 0. Το `FLAG` γίνεται 2 στην ρουτίνα εξυπηρέτησης της διακοπής `INT1`. Την τιμή 1 παίρνει μόνο μετά από την τιμή 2, αφού περάσουν 500ms, ενώ την τιμή 0 παίρνει μόνο μετά από την τιμή 1, αφού περάσουν άλλα 4500ms. Θέτουμε `COUNT = 4500` κάθε φορά που το `FLAG` μειώνεται ή μένει 0, και `COUNT = 500` στην ρουτίνα εξυπηρέτησης διακοπής `ISR1`, ενώ κάθε φορά που το `COUNT` μηδενίζεται, μείώνεται (αν γίνεται) η τιμή του `FLAG`. Το πόσα ms έχουν περάσει τα μετράμε με έναν μετρητή, `CNT`. Το ίδιο ακριβώς κάνουμε και πιο συνοπτικά στην `C` με τη κλήση της έτοιμης ρουτίνας `_delay_ms(1)`, και τις μεταβλητές `flg` και `count`

```asm {source=Ex2_3_asm/Ex2_3_asm/main.asm}
```

```c {source=Ex2_3c/Ex2_3c/main.c}
```