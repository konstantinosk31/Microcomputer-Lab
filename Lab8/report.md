---
#{{{
# vim: set conceallevel=0:
title: 'Συνδυαστική/Επαναληπτική άσκηση – Εφαρμογή Internet of Things'
subtitle: 'Εργαστήριο Μικροϋπολογιστών'
author:
- Κριθαρίδης Κωνσταντίνος, $el21045$
- Μπαλάτος Δημήτριος, $el21170$
date: '10 Δεκεμβρίου 2024'
subject: ''
keywords: ''
abstract: ''
lang: el_GR
linkcolor: blue
fontsize: 12pt
#fontfamily: 'GFS Artemisia'
mainfont: 'CMU Serif'
sansfont: 'CMU Sans Serif:style=BoldItalic'
monofont: 'CMU Typewriter Text:style=LightOblique'
documentclass: article
classoption: ''
toc: false
papersize: a4
geometry:
- margin=1.5cm
urlcolor: blue
toccolor: black
links-as-notes: false
numbersections: true
#}}}
---

# Ζήτημα 8.1

Στα ζητήματα αυτής της εργαστηριακής άσκησης, επειδή απαιτούταν η χρήση πολλών διαφορετικών συσκευών, αποφασίσαμε για καλύτερη διάρθρωση και τμηματοποίηση του κώδικα να χρησιμοποιήσουμε διαφορετικά header files, με τις μεθόδους υπεύθυνες για κάθε συσκευή.

Για το συγκεκριμένο ζήτημα, δημιουργήσαμε αρχικά το header file `usart.h` στο οποίο εισαγάγαμε τον κώδικα που δινόταν από την εκφώνηση για αρχικοποίηση, αποστολή και λήψη ενός byte, τον οποίο επεκτείναμε με τις μεθόδους που κρίναμε απαραίτητες. Πιο συγκεκριμένα, γράψαμε τις `usart_transmit_string` (στέλνει ένα string μέσω της UART), `usart_receive_string` (λαμβάνει ένα string από τη UART), `create_command` (φτιάχνει string που αντιστοιχεί στο format του ορισμού μεταβλητής στο payload), `create_payload` (φτιάχνει string για την εντολή payload), `usart_command` (στέλνει εντολή στο UART και λαμβάνει την απάντηση), `usart_restart` (κάνει restart το ESP8266) και `usart_connect` (πραγματοποιεί τη σύνδεση στο WiFi). Ο κώδικας του header file `usart.h` παρατίθεται στο τέλος, μαζί με όλα τα υπόλοιπα header files που χρησιμοποιήθηκαν για τα ζητήματα της εργαστηριακής άσκησης.

Επιπλέον, χρησιμοποιήσαμε την οθόνη LCD μέσω του Port Expander για να εμφανίζουμε τα ζητούμενα μηνύματα στην οθόνη, οπότε χρησιμοποιήσαμε και τον κώδικα που είχα γράψει σε προηγούμενες εργαστηριακές ασκήσεις για αυτά. Τα header files `pca9555.h` για το Port Expander και το `lcd_pex.h` που το χρησιμοποιεί για την οθόνη LCD παρατίθενται και αυτά στο τέλος της αναφοράς.

Στον πηγαίο κώδικα που ακολουθεί, αφού αρχικοποιήσουμε το USART, το PCA9555 και την οθόνη LCD, συνδεόμαστε στο WiFi (τυπώνοντας ανάλογα με την απάντηση που λαμβάνουμε το αντίστοιχο μήνυμα στην οθόνη), και, αφού περιμένουμε λίγο για να παρατηρήσουμε την απάντηση, ρυθμίζουμε το URL στο οποίο θα στέλνουμε δεδομένα (εμφανίζοντας πάλι ανάλογο μήνυμα στην οθόνη).

```c {source=Ex8_1/Ex8_1/main.c}
```

# Ζήτημα 8.2

Στο ζήτημα αυτό χρειάστηκε ακόμα επικοινωνία one-wire με τον αισθητήρα θερμοκρασίας DS18B20 (`ds18b20.h`), χρήση πληκτρολογίου (`keypad.h`) και χρήση του ποτενσιόμετρου POT0 με ADC (`pot.h`). Και αυτά τα header files παρατίθενται στο τέλος της αναφοράς.

Στον πηγαίο κώδικα, αφού αρχικοποιήσουμε το one-wire και το ADC0 για το ποτενσιόμετρο, επεκτείνοντας τον πηγαίο κώδικα του προηγούμενου ζητήματος, διαβάζουμε διαρκώς μετρήσεις θερμοκρασίας από το DS18B20, πίεσης από το POT0 (ρυθμίζοντας κατάλληλα τις μετρήσεις και των δύο) και το πληκτρολόγιο για εντολές. Αν πατηθεί το πλήκτρο '8', που αντιστοιχεί στο τελευταίο ψηφίο της ομάδας μας (28), το status γίνεται `NURSE CALL`. Αλλιώς, αν η πίεση είναι πάνω από 12 ή κάτω από 4 γίνεται `CHECK PRESSURE`, ενώ αν η θερμοκρασία είναι κάτω από 34 ή πάνω από 37 γίνεται `CHECK TEMP`. Αλλιώς, το status γίνεται `OK`. Το status είναι σε μορφή έτοιμη ώστε με τις `create_command` και `create_payload` να ενσωματωθεί στο payload. Τέλος, εμφανίζουμε στην 1η γραμμή της οθόνης LCD τις μετρήσεις θερμοκρασίας και πίεσης, και στην 2η γραμμή το status. Ο πηγαίος κώδικας αυτός αυτό φαίνεται παρακάτω.

```c {source=Ex8_2/Ex8_2/main.c}
```

# Ζήτημα 8.3

