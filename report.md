## Ζήτημα 2.1
Τροποποιούμε τον κώδικα του σχήματος 2.1. Προσθέτουμε ρουτίνα εξυπηρέτησης της διακοπής `INT1` που αυξάνει τον μετρητή διακοπών `INT1`, `int1counter`, κάνοντάς τον reset μετά την τιμή 63. Προσθέτουμε έλεγχο ώστε αν είναι πατημένο το `PB5` τη στιγμή που γίνεται η διακοπή, αυτή να μην καταχωρηθεί στον μετρητή διακοπών `INT1`. Επιπλέον προσθέτουμε την ροή ελέγχου `isrloop` ώστε να αποφύγουμε το φαινόμενο του σπινθηρισμού, σύμφωνα με το σχήμα 2.4.

## Ζήτημα 2.2
Για το Ζήτημα 2.2, τροποποιηθηκε ο δοσμένος κώδικας. Αρχικά αλλάξαμε το όριο μετρητή από 16 σε 32, όπως ζητήθηκε από την εκφώνηση. Για την αντιμετώπιση των interrupts, χρειάστηκε να αλλάξουμε ορισμένα σημεία ώστε να αντιστοιχούν στο `INT1` αντί του `INT0`. Η εξυπηρέτηση του interrupt καθαυτή είναι απλή, αξιοποιούμε βρόχο για να διαβάσουμε τα αναμμένα bits του `PORTB` (κρατάμε τα 5 LSBs με ενα bitwise AND) και τα εκτυπωνουμε.

## Ζήτημα 2.3
Για το Ζήτημα 2.3 χρησιμοποιούμε μια ρουτίνα `delay_mS` που καθυστερεί για 1ms. Κάθε ms ελέγχουμε σε ποιά κατάσταση βρίσκεται ο αυτοματισμός μας με βάση ένα `FLAG` (0: σβηστά LEDs, 1: `PB0` αναμμένο, 2: όλα τα LEDs του `PORTB` αναμμένα) που αρχικά είναι 0. Το `FLAG` γίνεται 2 στην ρουτίνα εξυπηρέτησης της διακοπής `INT1`. Την τιμή 1 παίρνει μόνο μετά από την τιμή 2, αφού περάσουν 500ms, ενώ την τιμή 0 παίρνει μόνο μετά από την τιμή 1, αφού περάσουν άλλα 4500ms. Θέτουμε `COUNT = 4500` κάθε φορά που το `FLAG` μειώνεται ή μένει 0, και `COUNT = 500` στην ρουτίνα εξυπηρέτησης διακοπής `ISR1`, ενώ κάθε φορά που το `COUNT` μηδενίζεται, μείώνεται (αν γίνεται) η τιμή του `FLAG`. Το πόσα ms έχουν περάσει τα μετράμε με έναν μετρητή, `CNT`. Το ίδιο ακριβώς κάνουμε και πιο συνοπτικά στην `C` με τη κλήση της έτοιμης ρουτίνας `_delay_ms(1)`, και τις μεταβλητές `flg` και `count`